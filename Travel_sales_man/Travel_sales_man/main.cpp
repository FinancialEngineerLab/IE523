// IE523: Financial Computing
// TSP Solver
// C++ Program written by Prof. R.S. Sreenivas
//
// The input file is to have the following format:
// Line 1: #vertices
// Line 2: First row of the cost matrix ie. a (1 x #vertices) row
// Line 3: Second row of the cost matrix ie. a (1 x #vertices) row
// Line 4: Third row of the cost matrix ie. a (1 x #vertices) row
// etc. etc. etc.

#include <iostream>
#include <iomanip>
#include <cmath>
#include <fstream>
#include <cstdlib>
#include <vector>

#include "lp_lib.h"

using namespace std;

// Setting the appropriate pointers for lpsolve
// keep in mind the size of the solution vector will depend on the data
// it has to the allocated dynamically.
lprec *lp;
double *solution;

// some global variables
int number_of_vertices;

// This routine is used to generate the next mask, which in turn
// is used to generate all possible subsets of the set of
// vertices using the procedure from the following source
// http://compprog.wordpress.com/2007/10/10/generating-subsets/
//
int next(int mask[], int n)
{
    int i;
    for (i = 0; (i < n) && mask[i]; ++i)
        mask[i] = 0;
    
    if (i < n)
    {
        mask[i] = 1;
        return 1;
    }
    return 0;
}

// I need this to check how many vertices are in a subset that
// is generated by the mask-procedure from
// http://compprog.wordpress.com/2007/10/10/generating-subsets/
// I need this for the RHS of the subtour elimination constraints
int size_of_mask(int mask[], int n)
{
    int size = 0;
    for (int i = 0; i < n; i++)
        if (mask[i] == 1)
            size++;
    return (size);
}

// This routine sets the ILP up based on the input data
void initialize_lp_from_input_data(char* argv[])
{
    // reading the input filename from commandline
    ifstream input_filename(argv[1]);
    
    if (input_filename.is_open()) {
        
        cout << "Input File Name: " << argv[1] << endl;
        
        // first line contains the number of items
        input_filename >> number_of_vertices;
        cout << "Number of Vertices = " << number_of_vertices << endl;
        
        // initialize the lp
        // there is a variable for each pair of vertices
        lp = make_lp(0, number_of_vertices*number_of_vertices);
        
        // now that we know the number of items, we can
        // set the size of the solution arrays
        solution = new double[number_of_vertices*number_of_vertices];
        
        // the row that defines the objective function should have
        // 1 + number_of_vertices*number_of_vertices items in it...
        // the 0-th element of this row is ignored.
        double objective_function[1+number_of_vertices*number_of_vertices];
        objective_function[0] = 0;
        // initializing the rest of the objective function
        {
            for (int i = 1; i <= (number_of_vertices*number_of_vertices); i++)
                input_filename >> objective_function[i];
        }
        // set the objective function
        set_obj_fn(lp, objective_function);
        
        // This keeps the message reporting of lp_solve to a minimum
        set_verbose(lp, 3);
        
        // the interpretation for the decision variables is this x(i,j) is
        // 1 (0) if the optimal tour takes (does not take) the arc from i to j
        {
            // the tour leaves every vertex
            for (int i = 1; i <= number_of_vertices; i++)
            {
                double row[1+(number_of_vertices*number_of_vertices)];
                for (int j = 0; j <= number_of_vertices*number_of_vertices; j++)
                    row[j] = 0;
                
                for (int j = 1; j <= number_of_vertices; j++)
                    row[(number_of_vertices*(i-1))+j] = 1;
                
                add_constraint(lp, row, EQ, 1);
            }
        }
        
        {
            // the tour enters every vertex
            for (int i = 1; i <= number_of_vertices; i++)
            {
                double row[1+(number_of_vertices*number_of_vertices)];
                for (int j = 0; j <= number_of_vertices*number_of_vertices; j++)
                    row[j] = 0;
                
                for (int j = 1; j <= number_of_vertices; j++)
                    row[(number_of_vertices*(j-1))+i] = 1;
                
                add_constraint(lp, row, EQ, 1);
            }
        }
        
        // we do not have to worry about forcing all x(i,i) variables to zero
        // (why?) -- because this is automatically done when we generate the
        // subtour elimination constraints for all singleton sets
        
        // subtour elimination constraints
        {
            int mask[number_of_vertices];
            
            // initialize mask to all zeros
            for (int i = 0; i < number_of_vertices; i++)
                mask[i] = 0;
            
            // start adding constraints for each
            while ((next(mask, number_of_vertices)==1) &&
                   (size_of_mask(mask, number_of_vertices) < number_of_vertices))
            {
                double row[1+(number_of_vertices*number_of_vertices)];
                for (int i = 0; i <= number_of_vertices*number_of_vertices; i++)
                    row[i] = 0;
                
                for (int i = 1; i <= number_of_vertices; i++)
                {
                    for (int j = 1; j <= number_of_vertices; j++)
                    {
                        if ((mask[i-1] == 1) && (mask[j-1] == 1))
                            row[((i-1)*number_of_vertices) + j] = 1;
                    }
                }
                // add constraint
                add_constraint(lp, row, LE, size_of_mask(mask, number_of_vertices)-1);
            }
        }
        
        // all variables are binary
        {
            for (int i = 1; i <= number_of_vertices*number_of_vertices; i++) {
                set_bounds (lp, i, 0.0, 1.0);
                set_int (lp, i, TRUE);
            }
        }
    }
    else {
        cout << "Input file missing" << endl;
        exit(0);
    }
}

// This routine solves the TSP instance.
// The procedure of extracting the optimal TSP path from the solution from
// lpsolve takes some effort to follow -- otherwise this is quite routine.
void solve_the_TSP()
{
    int ret;
    
    // solve the ILP
    ret = solve(lp);
    
    if (ret == 0)
    {
        // get the optimal assignment
        get_variables(lp, solution);
        
        cout << "Optimal Tour" << endl << "Vertex 1 --> Vertex ";
        for (int i = 0; i < number_of_vertices*number_of_vertices; i++)
        {
            if (solution[i] == 1)
                if (((i+1)%number_of_vertices != 0) && ((i+1)%number_of_vertices != 1))
                    cout << (i+1)%number_of_vertices << " --> Vertex ";
                else {
                    if ((i+1)%number_of_vertices == 0)
                        cout << number_of_vertices << " --> Vertex ";
                    else {
                        cout << 1 << endl;
                    }
                }
        }
        
        // optimal cost of the Hamiltonian Tour
        cout << "Optimal Tour Length = " << get_objective(lp) << endl;
    }
    else {
        cout << "Problem is infeasible, check input file... something went wrong" << endl;
    }
}

int main (int argc, char* argv[]) 
{
    // formulate the the TSP ILP from input data
    initialize_lp_from_input_data(argv);
    
    // solve the TSP instance
    solve_the_TSP();
    
    return(0);
}
